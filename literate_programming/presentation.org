* Literate programming in Org-mode
** TODO Org-mode

The first thing I will do is to show how an ~.org~ file looks in
fundamental-mode. It's actually nothing more than a text file.

*** Content

Here are some of the basics we can have a look at:

- Headings, how to create them and change them
- What kinds of lists are supported
- How tables look like
- TODO:s


**** My favorite things
1) That it's just plain text files
2) It's automatic adjustments

**** Commands

Good to know commands in Org-mode

| Command           | Action          |
|-------------------+-----------------|
| Tab heading       | Demotes heading |
| Shift-Tab heading | Promote heading |
| C-Enter           |                 |
| M-Enter           |                 |

** Literate programming

When I started to use Emacs I found the talk from ~Howard Abrams~, [[https://www.youtube.com/watch?v=dljNabciEGg][Literate
Devops with Emacs]], in which he talked about the art of literate programming.
Howard is an inspiration for me in general since I often find he has some novel
and well thought through ideas.

He has another blog post, [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][introduction to Literate Programming]], which I was very
inspired when writing this post. I will try to make it my own take on his post
since I will focus on the aspects that I currently use org-mode for when it
comes to literate programming.

[[https://en.wikipedia.org/wiki/Literate_programming][Literate programming]] for me is the possibility to mix text and code. I think the
thought of having code to be self explanatory as much is possible is good, and
only add comments when they are actually meaningful. But that goes for the code
that I share with others. For my own understanding notes are very valuable. I
like to document what I am doing and trying. Cause there might be sometime soon
that I need to redo something and it's also valuable if I want to later explain
how something work to somebody else.


*** Babel
One way of indulging into literate programming is to utilize [[https://orgmode.org/worg/org-contrib/babel/][Babel, active code
in Org-mode]]. This makes it possible to create code blocks that can be mixed with
regular text. For anyone that has tried out these python notebooks might be
familiar with this.

One of the benefits of babel is that it supports many languages and they can all
be included within the same org document. For me personally these languages
includes ~C++~, ~Python~, ~Shell~ and ~Elisp~. Since I am not an expert in any
of these languages I often end up in situations where I want to experiment and
document my progress it's great that they all can be used within the same tool.
Another great benefit is that org documents are plain text documents they are
easy to version control and are safe proof for the future.

*** A

We can create a babel block very easily with ~<s~ followed by ~TAB~

*** B
#+BEGIN_SRC sh
echo "hello there!"
#+END_SRC

#+RESULTS:
: hello there!

#+BEGIN_SRC elisp
(format "hello there")
#+END_SRC

#+RESULTS:
: hello there

#+BEGIN_SRC python
print("hello there")
#+END_SRC

#+RESULTS:
: None

#+BEGIN_SRC python
return "hello there"
#+END_SRC

#+RESULTS:
: hello there

#+BEGIN_SRC python :results output
print("hello there")
#+END_SRC

#+RESULTS:
: hello there

*** C

We are of course not only limited to perform simple operations like
~hello-world~. Here is an example using the ~Eigen~ library and the ~c++17~ compiler.

#+BEGIN_SRC C++ :flags '("-I ~/Dropbox/Code/Eigen" "-std=c++17") :results output
#include <iostream>
#include <Eigen/Dense>
using namespace Eigen;
using namespace std;
int main()
{
  Matrix3d m = Matrix3d::Random();
  m = (m + Matrix3d::Constant(1.2)) * 50;
  cout << "m =" << endl << m << endl;
  Vector3d v(1,2,3);

  cout << "m * v =" << endl << m * v << endl;
}
#+END_SRC

#+RESULTS:
: m =
: 94.0188  89.844 43.5223
: 49.4383 101.165  86.823
: 88.3099 29.7551 37.7775
: m * v =
: 404.274
: 512.237
: 261.153

** Chain

Mixing text and blocks of code seems to work great from the examples so far.
This block works as well but what would happen if we for our own understandings
sake would like to split up the block further?
#+BEGIN_SRC sh :results output
MY_NAME="Niklas"
echo $MY_NAME
#+END_SRC

#+RESULTS:
: Niklas

*** 1
Let's create a variable
#+BEGIN_SRC sh :results silent
MY_NAME="Niklas"
#+END_SRC

And let's print it's value
#+BEGIN_SRC sh :results ouput
echo $MY_NAME
#+END_SRC

#+RESULTS:

That doesn't work, and that's because after a block has been evaluated that
shell session is terminated. We would need for them to somehow share the same
session and to make it persistent so it doesn't die.

*** 2
:PROPERTIES:
:header-args: :session session-shell-chain
:END:

Let's create a variable
#+BEGIN_SRC sh :results silent
MY_NAME="Niklas"
#+END_SRC

And let's print it's value
#+BEGIN_SRC sh :results ouput
echo $MY_NAME
#+END_SRC

#+RESULTS:
: Niklas

*** 3
:PROPERTIES:
:header-args: :session session-python-chain
:END:

This works with other languages that supports [[https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop][interactive
repls]](read-eval-print-loop).

#+BEGIN_SRC python :results output
def calculate_sum(numbers):
    sum = 0
    for number in numbers:
       sum += number

    return sum
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :results output
numbers = [x for x in range(20)]
print("The sum of the numbers is: " + str(calculate_sum(numbers)))
#+END_SRC

#+RESULTS:
: The sum of the numbers is: 190

** Compose

Chaining blocks through ~sessions~ as we saw where useful for some types of
languages like ~python~ and ~shells~. But that is not the only way. For me it
can make sense to make the blocks as small as needed. That might differ
depending on context. So we shall look more into how to compose different
blocks. This is a feature called ~noweb~.

*** A

Let's take the previous python example.

This is where we create our function
#+NAME: python-calc
#+BEGIN_SRC python
def calculate_sum(numbers):
    sum = 0
    for number in numbers:
       sum += number

    return sum
#+END_SRC

And here we create the data dn call the function
#+BEGIN_SRC python :results output :noweb yes
<<python-calc>>
numbers = [x for x in range(20)]
print("The sum of the numbers is: " + str(calculate_sum(numbers)))
#+END_SRC

#+RESULTS:
: The sum of the numbers is: 190

*** B

But we can also create blocks which returns something simple like a value and
use that in the other code
#+NAME: python-max-numbers
#+BEGIN_SRC python
return 30
#+END_SRC

#+BEGIN_SRC python :results output :noweb yes
<<python-calc>>
numbers = [x for x in range(<<python-max-numbers()>>)]
print("The sum of the numbers is: " + str(calculate_sum(numbers)))
#+END_SRC

#+RESULTS:
: The sum of the numbers is: 435

*** C

Why not mix languages as well, ~python~ and ~elisp~ working together
#+NAME: elisp-max-numbers
#+BEGIN_SRC elisp
(/ (* 10 (+ 30 5 2)) 5)
#+END_SRC

#+RESULTS: elisp-max-numbers
: 74

#+BEGIN_SRC python :results output :noweb yes
<<python-calc>>
numbers = [x for x in range(<<elisp-max-numbers()>>)]
print("The sum of the numbers is: " + str(calculate_sum(numbers)))
#+END_SRC

#+RESULTS:
: The sum of the numbers is: 2701

** Note taking

I started to take notes with Org-mode and soon I found myself reading a
programming book and realized how greatly suited Org is for that use case.

I will open my notes file that I have and navigate to a section with notes from
the book

With Org-mode I can then easily take notes and experiment with the programming
examples that exists in the book. For me that is a perfect match which makes it
much easier for me to grasp the concepts.

However now when I am reading the notes in hindsight they aren't as clear as
they where when I took them. I think what I am missing is the actual context
from within they where taken. I guess I need to open the pdf and look for clues.

That would be if I didn't have Org-mode ... But with the package ~Org-Noter~ I
get exactly this. So I will call the function ~M-x org-noter~ and I
automatically get a split view with my notes and with the actual pdf file.
[[file:~/org/hacking_notebook.org::*The%20if%20Special%20Form][An introduction to Elisp: The if Special Form]]

Even though linking to other files is useful I am again feeling that I am
lacking the context sometimes. Sure it's useful if I want to reference the whole
file but not if there is a subpart of it. Luckily there is a cool solution to
that which involves ~org-capture~. Let's use ~find-function~ to have a look at
the implementation.

** Our own image

I don't build Docker images that often so it would be really useful if I could
document the procedure both for later reference. On Arch Linux I don't
have [[https://www.docker.com/][Docker]] installed so that is the first step.

*** Installation

I found docker related instructions on the [[https://wiki.archlinux.org/index.php/docker][arch wiki]]. So first we install docker
with the package manager:
#+BEGIN_SRC sh
sudo pacman -S docker
#+END_SRC

Next we start the docker service, yes that's right we can run sudo commands from
the blocks as well.
#+BEGIN_SRC sh :dir "/sudo::" :results none
sudo systemctl start docker
#+END_SRC

Now we want to make sure that the docker can be run as expected. I will use the
~hello-world~ image to try that out
#+BEGIN_SRC sh :results raw
docker run hello-world
#+END_SRC

Unfortunately this gives an error with the following message:
#+BEGIN_EXAMPLE
docker: Got permission denied while trying to connect to the Docker daemon
socket at unix:///var/run/docker.sock: Post
http://%2Fvar%2Frun%2Fdocker.sock/v1.39/containers/create: dial unix
/var/run/docker.sock: connect: permission denied.
See 'docker run --help'.
#+END_EXAMPLE

[[https://techoverflow.net/2017/03/01/solving-docker-permission-denied-while-trying-to-connect-to-the-docker-daemon-socket/][This]] article discusses the same problem and it seems like it can be solved if I
get elevated rights. That can be achieved by letting me be part of the group docker.
I currently belong to these groups:
#+BEGIN_SRC sh
groups niklascarlsson
#+END_SRC

#+RESULTS:
: vboxsf niklascarlsson

But I want to belong to the docker group as well, so I will need to run a
command to achieve that. It will require me to use sudo which we can achieve
thanks to [[https://www.emacswiki.org/emacs/TrampMode][TRAMP]](Transparent Remote Access, Multiple Protocols)
#+BEGIN_SRC sh :dir "/sudo::""
sudo gpasswd -a niklascarlsson docker
#+END_SRC

#+RESULTS:
: Adding user niklascarlsson to group docker

Let's verify that it worked:
#+BEGIN_SRC sh
groups niklascarlsson
#+END_SRC

#+RESULTS:
: vboxsf docker niklascarlsson

In order for it to really take effect we need to either logout or reboot. So I
will reboot in order to get my permissions. Now we are back and can run the
~hello-world~ again:
#+BEGIN_SRC sh :results output
docker run hello-world
#+END_SRC

#+RESULTS:
#+begin_example

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/

#+end_example

Perfect, we have a working docker installation. Now let's build ourselves an image.

*** Build an image
:PROPERTIES:
:header-args: :results output :mkdirp yes
:END:

I would like to build a docker image with ~Python3~ installed so that I can run
my python3 code. I got the inspiration from this [[https://blog.realkinetic.com/building-minimal-docker-containers-for-python-applications-37d0272c52f3][minimal docker image]] example.

**** Requirements

We need to specify the requirements that we are demanding:
#+BEGIN_SRC text :tangle docker_image/requirements.txt
Flask>=0.12,<0.13
flask-restplus>=0.9.2,<0.10
Flask-SSLify>=0.1.5,<0.2
Flask-Admin>=1.4.2,<1.5
gunicorn>=19,<20
#+END_SRC

By using the ~mkdirp~ setting I am able to automatically create the needed
directory structure. This setting I want for all my blocks so I set it as a
property of the subtree.

**** Dockerfile

The ~Dockerfile~ specifying the commands for building the image:
#+BEGIN_SRC text :tangle docker_image/Dockerfile
FROM python:3.6-alpine

COPY requirements.txt /

RUN pip install -r /requirements.txt

COPY src/ /app
WORKDIR /app

CMD ["python", "app.py"]
#+END_SRC

**** The application

This is my application that I want to deploy in the docker
#+BEGIN_SRC python :tangle docker_image/src/app.py
for i in range(20):
    print "i has the value " + str(i)
#+END_SRC

**** Create the image

#+BEGIN_SRC sh :dir docker_image
docker build -t minimal_python .
#+END_SRC

First we verify that the image is now available among the docker images
#+BEGIN_SRC sh
docker images
#+END_SRC

Nice, let's try the image
#+BEGIN_SRC sh
docker run minimal_python
#+END_SRC

Oh no ... There is an issue. The python code we wrote where not compatible, let's
go back and fix that. One way would be to fix the source code, tangle all the
blocks and rebuild the image to see if it works. That approach would work but
let's investigate another route ...

*** Improve it II

#+BEGIN_SRC elisp
(defun docker-match (name-regexp)
  ;; return the name of the last docker image which matches the input
  ;; NAME-REGEXP
  (with-temp-buffer (shell-command "docker ps" t)
                    (goto-char (point-min))
                    (let ((name-match '()))
                      (while (not (eobp))
                        (let ((current-name (string-trim (thing-at-point 'line))))
                          (if (string-match name-regexp current-name)
                              (progn
                                (end-of-line)
                                (setq name-match (format "%s" (thing-at-point 'symbol))))))
                        (forward-line 1))
                      name-match)))

(defun docker-path (name-regexp  &optional extended-path)
  (if extended-path
      (format "/docker:%s:/%s" (docker-match name-regexp) extended-path)
    (format "/docker:%s:/" (docker-match name-regexp))))

(docker-path "minimal_python")
(docker-path "minimal_python" "app")
#+END_SRC

#+RESULTS:
: /docker:trusting_banzai:/

#+BEGIN_SRC sh :session session-docker-agent :dir (my/docker-path "minimal_python" "app")
ls
#+END_SRC

#+RESULTS:
|                                          |
| $ [0;0mapp.py[m   [0;0mapp2.py[m |


#+BEGIN_SRC python :tangle (my/docker-path "minimal_python" "app/app3.py")
for i in range(20):
    print("i has the value " + str(i))
#+END_SRC

#+BEGIN_SRC sh :session session-docker-agent :results output
python app3.py
#+END_SRC

#+RESULTS:
#+begin_example
i has the value 0
i has the value 1
i has the value 2
i has the value 3
i has the value 4
i has the value 5
i has the value 6
i has the value 7
i has the value 8
i has the value 9
i has the value 10
i has the value 11
i has the value 12
i has the value 13
i has the value 14
i has the value 15
i has the value 16
i has the value 17
i has the value 18
i has the value 19
#+end_example

** Performance analysis
#+LaTeX_HEADER: \usepackage{minted}
#+LaTeX_HEADER: \usemintedstyle{paraiso-light}
Let's make a fun little investigation. Assume we have some data of a signal and
we want to make an algorithm that tracks the 1-d signal. This presentation is a
little bit too short to make a real algorithm and data in so we will fake it
instead
*** Synthesize the data
Let's use some Emacs lisp to generate the ground truth and the estimates for us:

#+BEGIN_SRC emacs-lisp :results value table :post addhdr(*this*) :exports both
  (mapcar (lambda (i)
            (list i (+ (random 4) (- i 2))))
          (number-sequence 1 20))
#+END_SRC

#+CAPTION: Truth and Estimate
#+NAME: est-truth-data
#+RESULTS:
|-------+----------|
| Truth | Estimate |
|-------+----------|
|     1 |        2 |
|     2 |        1 |
|     3 |        3 |
|     4 |        2 |
|     5 |        6 |
|     6 |        7 |
|     7 |        7 |
|     8 |        9 |
|     9 |        9 |
|    10 |        9 |
|    11 |       11 |
|    12 |       10 |
|    13 |       14 |
|    14 |       15 |
|    15 |       13 |
|    16 |       15 |
|    17 |       15 |
|    18 |       18 |
|    19 |       18 |
|    20 |       21 |

#+name: addhdr
#+begin_src emacs-lisp :var tbl=""
(cons 'hline (cons '("Truth" "Estimate") (cons 'hline tbl)))
#+end_src

Let's give the results a name so that we can reference the table later. It's
good to see the data in the table but I often find that some kind of
visualization is more powerful. It's too bad I don't know how to plot in
elisp... but I do know how to do it in Python.

*** Visualize estimate and truth
#+BEGIN_SRC python :session my-plot-session :var data=est-truth-data :results file :exports both
import numpy as np
import matplotlib
matplotlib.use('Agg')
from matplotlib import pyplot as plt

# Convert list to numpy array
truth = np.asarray(data)[:, 0]
est = np.asarray(data)[:, 1]
# Plot
fig=plt.figure()
plt.plot(truth, color="g", label="Truth")
plt.plot(est, marker="x", label="Estimate")
plt.legend(loc='upper left')
plt.xlabel("Sample")
plt.ylabel("Value")
plt.title("Tracking")
plt.savefig('.images/est_vs_truth.png')
'.images/est_vs_truth.png' # return this to org-mode
#+END_SRC

#+CAPTION: Tracking the true value
#+RESULTS:
[[file:.images/est_vs_truth.png]]

Cool, the performance of the fake algorithm is not that bad. I think we can be
pretty happy with it. let's see if we can gather some more information about
it's performance.

*** Examine the performance

|------------------+-------------------+-------+----------------|
|            Truth |          Estimate | Error | Absolute error |
|------------------+-------------------+-------+----------------|
|                1 |                 1 |     0 |              0 |
|                2 |                 2 |     0 |              0 |
|                3 |                 3 |     0 |              0 |
|                4 |                 4 |     0 |              0 |
|                5 |                 5 |     0 |              0 |
|                6 |                 7 |    -1 |              1 |
|                7 |                 8 |    -1 |              1 |
|                8 |                 9 |    -1 |              1 |
|                9 |                 8 |     1 |              1 |
|               10 |                 8 |     2 |              2 |
|               11 |                 9 |     2 |              2 |
|               12 |                11 |     1 |              1 |
|               13 |                11 |     2 |              2 |
|               14 |                13 |     1 |              1 |
|               15 |                14 |     1 |              1 |
|               16 |                16 |     0 |              0 |
|               17 |                15 |     2 |              2 |
|               18 |                17 |     1 |              1 |
|               19 |                20 |    -1 |              1 |
|               20 |                21 |    -1 |              1 |
|------------------+-------------------+-------+----------------|
| Number of values |                20 |       |                |
|       Mean error |               0.9 |       |                |
|             RMSE | 1.140175425099138 |       |                |
|------------------+-------------------+-------+----------------|
#+TBLFM: @2$1..@21$1='(identity remote(est-truth-data, @@#$1))::@2$2..@21$2='(identity remote(est-truth-data, @@#$2))::@2$3..@21$3=$1-$2::@2$4..@21$4='(abs (- $1 $2));N::@22$2='(length (list @2$4..@21$4));N::@23$2='(org-sbe "mean" (error @2$4..@21$4))::@24$2='(org-sbe "rmse" (estimate @2$1..@21$1) (truth @2$2..@21$2))

In order to get the values from the other table I am using [[https://orgmode.org/manual/References.html#index-remote-references-352][remote references]]. To
refer to the values of the other table.

Table
thinking of ~Windows calc~ when I hear this name. But this is something
different.

Tables also supports ~Emacs lisp~ so we can use that to calculate the absolute
error. Finally it would be nice to get a KPI like ~rmse~ to have one number for
the performance of the algorithm. Since that equation would be quite long in
Emacs lisp maybe it's time to try something else.

We can actually pass the data from the table into other code blocks, which is a
super cool. We can therefore create a block with Python code which we pass values
into in order to be able to calculate the [[https://en.wikipedia.org/wiki/Root-mean-square_deviation][rmse]]

#+NAME: rmse
#+BEGIN_SRC python :var estimate=0 :var truth=0 :exports none
import numpy as np
error = np.asarray(estimate) - np.asarray(truth)
result = np.sqrt(np.mean(np.square(error)))
return result
#+END_SRC

#+NAME: mean
#+BEGIN_SRC elisp :var error=0 :exports none
(let ((num-values (length error)))
  (/ (seq-reduce '+ error 0.0) num-values))
#+END_SRC

A second try

*** Describe the flow

I would like to describe the flow better. It would be great if we could
visualize it, perhaps in a flow chart.

#+BEGIN_SRC plantuml :file .images/flow.png :exports results
@startuml
(*) --> "Synthesize data with Elisp"

if "Improve results with post" then
  -->[Visualize the data] "Python and matplotlib"
else
  ->[Process the data] "Table formulas"
  -->[Elisp, calc and code blocks] "Visualize the flow"
  -->[plantUML] (*)
endif
@enduml
#+END_SRC

#+CAPTION: The flow of our investigation
#+RESULTS:
[[file:.images/flow.png]]

*** Export

I think that our investigation here has been a success and it would be great if
we can share the findings with our colleges. Unfortunately not all of them have
access to Org-mode and can read the information in this format. Cause as we saw
before this is just plain text so it won't look as nice outside this
environment.

Luckily Org-mode supports a lot of different exports. I am thinking for this
particular use case something common like a ~pdf~ would be a good choice. We
also would like it to look nice and professional so let's make it a ~LaTeX~
styled pdf.

To export we only need to use the function ~M-x org-latex-export-to-pdf~. There
are two other alternatives here using ~pandoc~ but I didn't find the export as
good so I will choose the first one.

One thing that did bother me though is that now I exported the file and the next
step would naturally be to look at the results. If you noticed with pandoc there
was a function called ~M-x org-pandoc-export-to-latex-pdf-and-open~. I want that
too cause if we open ~dired~ the directory editor we can see that the file is
indeed here.

But I want this automated, good thing that we are using Emacs then, let's create
the function we need.

*** Improve

So I already prepared for this and this is the elisp code we need to have a
function which also will open the pdf after the export has finished.

#+BEGIN_SRC elisp
(defun org-latex-export-to-pdf-and-open ()
"Export current buffer to LaTeX then process through to PDF and open the
resulting file"
  (interactive)
  (let* ((file-name (file-name-nondirectory buffer-file-name))
        (name (file-name-sans-extension file-name)))
  (org-latex-export-to-pdf)
  (find-file (concat name ".pdf"))))
#+END_SRC

We can see that it has the name ~pdf-and-open~. Firstly it retrieves the name of
the current file, without the extension. Then it calls the regular function and
lastly opens the exported PDF.

To install it I just open it in the popup buffer and evaluate the function and
now when I search through ~M-x~ I will find the function and it will do exactly
what we want.

*** Visual :noexport:
Some notes on how to get syntax highlighting to work for exported latex pdf
[[https://emacs.stackexchange.com/questions/20839/exporting-code-blocks-to-pdf-via-latex/20841#20841][here]] and [[https://stackoverflow.com/questions/21005885/export-org-mode-code-block-and-result-with-different-styles/21007117#21007117][here]]. The takeaways where:

- Install pygmentize
- Install minted

Installing them using pacman
#+BEGIN_SRC sh :results output
pacman -Ss "minted"
#+END_SRC

#+RESULTS:
: community/minted 2.5-1
:     Syntax highlighted source code for LaTeX

#+BEGIN_SRC sh :results output
pacman -Ss "pygmentize"
#+END_SRC

#+RESULTS:
: community/pygmentize 2.2.0-2
:     Python syntax highlighter

To be able to see which styles we can choose from we can ask ~pygmentize~
#+BEGIN_SRC sh :results output
pygmentize -L styles
#+END_SRC

#+RESULTS:
#+begin_example
Pygments version 2.2.0, (c) 2006-2017 by Georg Brandl.

Styles:
~~~~~~~
,* default:
    The default style (inspired by Emacs 22).
,* emacs:
    The default style (inspired by Emacs 22).
,* friendly:
    A modern style based on the VIM pyte theme.
,* colorful:
    A colorful style, inspired by CodeRay.
,* autumn:
    A colorful style, inspired by the terminal highlighting style.
,* murphy:
    Murphy's style from CodeRay.
,* manni:
    A colorful style, inspired by the terminal highlighting style.
,* monokai:
    This style mimics the Monokai color scheme.
,* perldoc:
    Style similar to the style used in the perldoc code blocks.
,* pastie:
    Style similar to the pastie default style.
,* borland:
    Style similar to the style used in the borland IDEs.
,* trac:
    Port of the default trac highlighter design.
,* native:
    Pygments version of the "native" vim theme.
,* fruity:
    Pygments version of the "native" vim theme.
,* bw:

,* vim:
    Styles somewhat like vim 7.0
,* vs:

,* tango:
    The Crunchy default Style inspired from the color palette from the Tango Icon Theme Guidelines.
,* rrt:
    Minimalistic "rrt" theme, based on Zap and Emacs defaults.
,* xcode:
    Style similar to the Xcode default colouring theme.
,* igor:
    Pygments version of the official colors for Igor Pro procedures.
,* paraiso-light:

,* paraiso-dark:

,* lovelace:
    The style used in Lovelace interactive learning environment. Tries to avoid the "angry fruit salad" effect with desaturated and dim colours.
,* algol:

,* algol_nu:

,* arduino:
    The ArduinoÂ® language style. This style is designed to highlight the Arduino source code, so exepect the best results with it.
,* rainbow_dash:
    A bright and colorful syntax highlighting theme.
,* abap:

#+end_example

We also need to add some code in the ~config.el~ file.
#+BEGIN_SRC elisp
(require 'ox-latex)
(add-to-list 'org-latex-packages-alist '("" "minted"))
(setq org-latex-listings 'minted)

(setq org-latex-pdf-process
      '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+END_SRC

*** Bonus :noexport:

Now I thought that this article deserved some bonus information about Emacs
calculator. I knew about it before but writing this part got me interested into
knowing more. And I think that it was a good example of one of the aspects that
I love about Org-mode which is to be able to experiment. I found some useful
[[https://github.com/dfeich/org-babel-examples/blob/master/calc/calc.org][calc-babel-examples]] and [[http://ehneilsen.net/notebook/orgExamples/org-examples.html][org-examples]] which I took inspiration from.


We can start of simple with some arithmatic:
#+BEGIN_SRC calc
10 + 3 * 5 /2.0
#+END_SRC

#+RESULTS:
: 17.5

**** I

But the calculator knows more than that. We can also calculate ~cosine~. It
seems however that it doesn't use SI units which is probably some setting
somewhere that needs to be set.
#+BEGIN_SRC calc
cos(180)
#+END_SRC

#+RESULTS:
: -1

**** II

Oh but let's have a look at this equation system, could calc solve that for us
too?
#+BEGIN_EXAMPLE
x*2+x=4,x
#+END_EXAMPLE

***** A

Yes we can!
#+BEGIN_SRC calc
fsolve(x*2+x=4,x)
#+END_SRC

***** B

So wait if we can do that, and it's supported in formulas that would mean that
we would be able to use it like this:

| Expression | Derivative |
|------------+------------|
| sqrt(x)    |            |
| cos(x)     |            |
| x^2        |            |
| 1/x^2      |            |
#+TBLFM: $2=deriv($1,x)

** Summary
#+OPTIONS: num:nil reveal_control:nil toc:nil
#+OPTIONS: reveal_title_slide:nil reveal_slide_number:nil
#+REVEAL_THEME: moon
#+REVEAL_TRANS: slide

*** What have we learnt?

- Org-mode makes it easy to get your information in context
- Org-mode makes it easy to export your documents into reports or presentations

*** One more thing ... :noexport:

Link to blog post

